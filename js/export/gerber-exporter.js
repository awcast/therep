/**
 * Gerber file export functionality for PCB manufacturing
 */

class GerberExporter {
    constructor(pcbEditor) {
        this.pcbEditor = pcbEditor;
        this.settings = {
            units: 'mm', // 'mm' or 'inches'
            precision: 6, // decimal places
            zeroSuppression: 'leading', // 'leading' or 'trailing'
            coordinateFormat: '3.6', // integer.decimal digits
            includeAttributes: true,
            mergePads: true,
            generateDrillFile: true,
            layerMapping: {
                'top-copper': 'F.Cu',
                'bottom-copper': 'B.Cu',
                'top-silk': 'F.SilkS',
                'bottom-silk': 'B.SilkS',
                'top-mask': 'F.Mask',
                'bottom-mask': 'B.Mask',
                'edge-cuts': 'Edge.Cuts'
            }
        };
        
        this.apertures = new Map();
        this.apertureIndex = 10; // Start apertures at D10
        this.drillTools = new Map();
        this.drillToolIndex = 1;
    }

    /**
     * Export all Gerber files as a ZIP
     */
    async exportGerberSet() {
        const files = {};
        const layers = this.getLayersToExport();
        
        // Generate Gerber files for each layer
        for (const [layerName, fileName] of Object.entries(layers)) {
            const objects = this.getObjectsForLayer(layerName);
            if (objects.length > 0 || layerName === 'edge-cuts') {
                files[fileName] = this.generateGerberFile(layerName, objects);
            }
        }
        
        // Generate drill file
        if (this.settings.generateDrillFile) {
            const drillData = this.generateDrillFile();
            if (drillData.content) {
                files['drill.drl'] = drillData.content;
                files['drill_report.txt'] = drillData.report;
            }
        }
        
        // Generate pick and place file
        const pickAndPlace = this.generatePickAndPlaceFile();
        if (pickAndPlace) {
            files['assembly.csv'] = pickAndPlace;
        }
        
        // Generate fabrication notes
        files['fabrication_notes.txt'] = this.generateFabricationNotes();
        
        return files;
    }

    /**
     * Get layers to export
     */
    getLayersToExport() {
        const layers = {};
        
        Object.entries(this.settings.layerMapping).forEach(([pcbLayer, gerberName]) => {
            if (this.hasObjectsOnLayer(pcbLayer) || pcbLayer === 'edge-cuts') {
                layers[pcbLayer] = `${gerberName}.gbr`;
            }
        });
        
        return layers;
    }

    /**
     * Check if layer has objects
     */
    hasObjectsOnLayer(layer) {
        return this.pcbEditor.objects.some(obj => obj.layer === layer);
    }

    /**
     * Get objects for specific layer
     */
    getObjectsForLayer(layer) {
        return this.pcbEditor.objects.filter(obj => obj.layer === layer);
    }

    /**
     * Generate Gerber file for a specific layer
     */
    generateGerberFile(layerName, objects) {
        this.apertures.clear();
        this.apertureIndex = 10;
        
        let gerber = this.generateGerberHeader(layerName);
        gerber += this.generateApertures(objects);
        gerber += this.generateDrawingCommands(objects, layerName);
        gerber += this.generateGerberFooter();
        
        return gerber;
    }

    /**
     * Generate Gerber header
     */
    generateGerberHeader(layerName) {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        let header = 'G04 Generated by ModernPCB Editor*\n';
        header += `G04 Layer: ${layerName}*\n`;
        header += `G04 Generated on: ${timestamp}*\n`;
        header += 'G04 #@! TF.GenerationSoftware,ModernPCB,Editor,1.0*\n';
        header += `G04 #@! TF.FileFunction,${this.getFileFunction(layerName)}*\n`;
        header += 'G04 #@! TF.SameCoordinates,Original*\n';
        header += '%FSLAX36Y36*%\n'; // Format specification
        header += `%MO${this.settings.units.toUpperCase()}*%\n`; // Units
        header += 'G04 Aperture definitions*\n';
        
        return header;
    }

    /**
     * Get file function for layer
     */
    getFileFunction(layerName) {
        const functions = {
            'top-copper': 'Copper,L1,Top',
            'bottom-copper': 'Copper,L2,Bot',
            'top-silk': 'Legend,Top',
            'bottom-silk': 'Legend,Bot',
            'top-mask': 'Soldermask,Top',
            'bottom-mask': 'Soldermask,Bot',
            'edge-cuts': 'Profile,NP'
        };
        return functions[layerName] || 'Other,User';
    }

    /**
     * Generate apertures for objects
     */
    generateApertures(objects) {
        let apertures = '';
        
        // Add apertures for different object types
        objects.forEach(obj => {
            switch (obj.type) {
                case 'trace':
                    this.addCircularAperture(obj.width);
                    break;
                case 'via':
                    this.addCircularAperture(obj.outerDiameter);
                    break;
                case 'pad':
                    this.addPadAperture(obj);
                    break;
            }
        });
        
        // Convert apertures to Gerber format
        this.apertures.forEach((code, key) => {
            apertures += `%ADD${code}${key}*%\n`;
        });
        
        apertures += 'G04 End of aperture definitions*\n';
        return apertures;
    }

    /**
     * Add circular aperture
     */
    addCircularAperture(diameter) {
        const key = `C,${this.formatCoordinate(diameter)}`;
        if (!this.apertures.has(key)) {
            this.apertures.set(key, this.apertureIndex++);
        }
    }

    /**
     * Add pad aperture
     */
    addPadAperture(pad) {
        let key;
        
        if (typeof pad.size === 'object') {
            // Rectangular or oval pad
            const width = pad.size.width;
            const height = pad.size.height;
            
            switch (pad.shape) {
                case 'rect':
                case 'square':
                    key = `R,${this.formatCoordinate(width)}X${this.formatCoordinate(height)}`;
                    break;
                case 'oval':
                    key = `O,${this.formatCoordinate(width)}X${this.formatCoordinate(height)}`;
                    break;
                default:
                    key = `C,${this.formatCoordinate(Math.max(width, height))}`;
            }
        } else {
            // Circular or square pad
            switch (pad.shape) {
                case 'square':
                    key = `R,${this.formatCoordinate(pad.size)}X${this.formatCoordinate(pad.size)}`;
                    break;
                default:
                    key = `C,${this.formatCoordinate(pad.size)}`;
            }
        }
        
        if (!this.apertures.has(key)) {
            this.apertures.set(key, this.apertureIndex++);
        }
    }

    /**
     * Generate drawing commands
     */
    generateDrawingCommands(objects, layerName) {
        let commands = 'G04 Start of drawing commands*\n';
        commands += 'G01*\n'; // Linear interpolation mode
        commands += 'G75*\n'; // Multi-quadrant mode
        
        objects.forEach(obj => {
            commands += this.generateObjectCommands(obj);
        });
        
        return commands;
    }

    /**
     * Generate commands for specific object
     */
    generateObjectCommands(obj) {
        switch (obj.type) {
            case 'trace':
                return this.generateTraceCommands(obj);
            case 'via':
                return this.generateViaCommands(obj);
            case 'pad':
                return this.generatePadCommands(obj);
            default:
                return '';
        }
    }

    /**
     * Generate trace commands
     */
    generateTraceCommands(trace) {
        const apertureKey = `C,${this.formatCoordinate(trace.width)}`;
        const apertureCode = this.apertures.get(apertureKey);
        
        let commands = `G04 Trace from ${this.formatCoordinate(trace.startPoint.x)},${this.formatCoordinate(trace.startPoint.y)} to ${this.formatCoordinate(trace.endPoint.x)},${this.formatCoordinate(trace.endPoint.y)}*\n`;
        commands += `D${apertureCode}*\n`;
        commands += `G01X${this.formatCoordinate(trace.startPoint.x)}Y${this.formatCoordinate(trace.startPoint.y)}D02*\n`;
        commands += `X${this.formatCoordinate(trace.endPoint.x)}Y${this.formatCoordinate(trace.endPoint.y)}D01*\n`;
        
        return commands;
    }

    /**
     * Generate via commands
     */
    generateViaCommands(via) {
        const apertureKey = `C,${this.formatCoordinate(via.outerDiameter)}`;
        const apertureCode = this.apertures.get(apertureKey);
        
        let commands = `G04 Via at ${this.formatCoordinate(via.position.x)},${this.formatCoordinate(via.position.y)}*\n`;
        commands += `D${apertureCode}*\n`;
        commands += `G01X${this.formatCoordinate(via.position.x)}Y${this.formatCoordinate(via.position.y)}D03*\n`;
        
        return commands;
    }

    /**
     * Generate pad commands
     */
    generatePadCommands(pad) {
        let apertureKey;
        
        if (typeof pad.size === 'object') {
            const width = pad.size.width;
            const height = pad.size.height;
            
            switch (pad.shape) {
                case 'rect':
                case 'square':
                    apertureKey = `R,${this.formatCoordinate(width)}X${this.formatCoordinate(height)}`;
                    break;
                case 'oval':
                    apertureKey = `O,${this.formatCoordinate(width)}X${this.formatCoordinate(height)}`;
                    break;
                default:
                    apertureKey = `C,${this.formatCoordinate(Math.max(width, height))}`;
            }
        } else {
            switch (pad.shape) {
                case 'square':
                    apertureKey = `R,${this.formatCoordinate(pad.size)}X${this.formatCoordinate(pad.size)}`;
                    break;
                default:
                    apertureKey = `C,${this.formatCoordinate(pad.size)}`;
            }
        }
        
        const apertureCode = this.apertures.get(apertureKey);
        
        let commands = `G04 Pad at ${this.formatCoordinate(pad.position.x)},${this.formatCoordinate(pad.position.y)}*\n`;
        commands += `D${apertureCode}*\n`;
        commands += `G01X${this.formatCoordinate(pad.position.x)}Y${this.formatCoordinate(pad.position.y)}D03*\n`;
        
        return commands;
    }

    /**
     * Generate Gerber footer
     */
    generateGerberFooter() {
        let footer = 'G04 End of drawing commands*\n';
        footer += 'M02*\n'; // End of file
        return footer;
    }

    /**
     * Generate drill file
     */
    generateDrillFile() {
        const drillHoles = this.getDrillHoles();
        if (drillHoles.length === 0) {
            return { content: null, report: null };
        }
        
        this.drillTools.clear();
        this.drillToolIndex = 1;
        
        // Group holes by size
        const holesBySize = new Map();
        drillHoles.forEach(hole => {
            const size = hole.diameter;
            if (!holesBySize.has(size)) {
                holesBySize.set(size, []);
            }
            holesBySize.get(size).push(hole);
        });
        
        // Generate tool definitions
        let drillFile = '; Drill file generated by ModernPCB Editor\n';
        drillFile += '; Format: Excellon\n';
        drillFile += `; Created: ${new Date().toISOString()}\n`;
        drillFile += 'M48\n'; // Begin header
        drillFile += `FMAT,2\n`; // Format
        drillFile += `${this.settings.units.toUpperCase()},${this.settings.coordinateFormat.replace('.', ':')}\n`;
        
        // Tool definitions
        holesBySize.forEach((holes, diameter) => {
            const toolNumber = this.drillToolIndex++;
            this.drillTools.set(diameter, toolNumber);
            drillFile += `T${toolNumber.toString().padStart(2, '0')}C${this.formatCoordinate(diameter)}\n`;
        });
        
        drillFile += '%\n'; // End header
        drillFile += 'G90\n'; // Absolute coordinates
        drillFile += 'G05\n'; // Drill mode
        
        // Drill commands
        holesBySize.forEach((holes, diameter) => {
            const toolNumber = this.drillTools.get(diameter);
            drillFile += `T${toolNumber.toString().padStart(2, '0')}\n`;
            
            holes.forEach(hole => {
                drillFile += `X${this.formatCoordinateInt(hole.position.x)}Y${this.formatCoordinateInt(hole.position.y)}\n`;
            });
        });
        
        drillFile += 'T00\n'; // End of program
        drillFile += 'M30\n'; // End of file
        
        // Generate drill report
        const report = this.generateDrillReport(holesBySize);
        
        return { content: drillFile, report: report };
    }

    /**
     * Get all drill holes from the PCB
     */
    getDrillHoles() {
        const holes = [];
        
        this.pcbEditor.objects.forEach(obj => {
            if (obj.type === 'via') {
                holes.push({
                    type: 'via',
                    diameter: obj.drillDiameter,
                    position: obj.position,
                    object: obj
                });
            } else if (obj.type === 'pad') {
                const drill = obj.getProperty('drill');
                if (drill && drill > 0) {
                    holes.push({
                        type: 'pad',
                        diameter: drill,
                        position: obj.position,
                        object: obj
                    });
                }
            }
        });
        
        return holes;
    }

    /**
     * Generate drill report
     */
    generateDrillReport(holesBySize) {
        let report = 'Drill Report\n';
        report += '============\n\n';
        report += `Generated: ${new Date().toLocaleString()}\n`;
        report += `Total holes: ${Array.from(holesBySize.values()).reduce((sum, holes) => sum + holes.length, 0)}\n`;
        report += `Tool count: ${holesBySize.size}\n\n`;
        
        report += 'Tools:\n';
        report += '------\n';
        holesBySize.forEach((holes, diameter) => {
            const toolNumber = this.drillTools.get(diameter);
            report += `T${toolNumber.toString().padStart(2, '0')}: ${this.formatCoordinate(diameter)}${this.settings.units} (${holes.length} holes)\n`;
        });
        
        return report;
    }

    /**
     * Generate pick and place file
     */
    generatePickAndPlaceFile() {
        const components = this.pcbEditor.objects.filter(obj => obj.type === 'component');
        if (components.length === 0) return null;
        
        let csv = 'Reference,Value,Package,X,Y,Rotation,Layer\n';
        
        components.forEach(component => {
            const reference = component.getProperty('reference', 'U?');
            const value = component.getProperty('value', 'N/A');
            const package_ = component.getProperty('package', 'N/A');
            const x = this.formatCoordinate(component.position.x);
            const y = this.formatCoordinate(component.position.y);
            const rotation = component.rotation || 0;
            const layer = component.layer;
            
            csv += `${reference},${value},${package_},${x},${y},${rotation},${layer}\n`;
        });
        
        return csv;
    }

    /**
     * Generate fabrication notes
     */
    generateFabricationNotes() {
        const stats = this.getDesignStatistics();
        
        let notes = 'PCB Fabrication Notes\n';
        notes += '=====================\n\n';
        notes += `Generated: ${new Date().toLocaleString()}\n\n`;
        
        notes += 'Design Information:\n';
        notes += `- Total objects: ${stats.totalObjects}\n`;
        notes += `- Traces: ${stats.traces}\n`;
        notes += `- Vias: ${stats.vias}\n`;
        notes += `- Pads: ${stats.pads}\n`;
        notes += `- Components: ${stats.components}\n\n`;
        
        notes += 'Layer Stack:\n';
        stats.layers.forEach(layer => {
            notes += `- ${layer}\n`;
        });
        notes += '\n';
        
        if (stats.drillSizes.length > 0) {
            notes += 'Drill Sizes:\n';
            stats.drillSizes.forEach(size => {
                notes += `- ${this.formatCoordinate(size)}${this.settings.units}\n`;
            });
            notes += '\n';
        }
        
        notes += 'Design Rules:\n';
        const rules = this.pcbEditor.designRules?.getAllRules() || {};
        Object.entries(rules).forEach(([rule, value]) => {
            notes += `- ${rule}: ${value}${this.settings.units}\n`;
        });
        
        return notes;
    }

    /**
     * Get design statistics
     */
    getDesignStatistics() {
        const stats = {
            totalObjects: this.pcbEditor.objects.length,
            traces: 0,
            vias: 0,
            pads: 0,
            components: 0,
            layers: new Set(),
            drillSizes: new Set()
        };
        
        this.pcbEditor.objects.forEach(obj => {
            stats[obj.type + 's'] = (stats[obj.type + 's'] || 0) + 1;
            stats.layers.add(obj.layer);
            
            if (obj.type === 'via') {
                stats.drillSizes.add(obj.drillDiameter);
            } else if (obj.type === 'pad') {
                const drill = obj.getProperty('drill');
                if (drill && drill > 0) {
                    stats.drillSizes.add(drill);
                }
            }
        });
        
        stats.layers = Array.from(stats.layers);
        stats.drillSizes = Array.from(stats.drillSizes).sort((a, b) => a - b);
        
        return stats;
    }

    /**
     * Format coordinate for Gerber output
     */
    formatCoordinate(value) {
        const multiplier = this.settings.units === 'mm' ? 1 : 25.4;
        return (value / multiplier).toFixed(this.settings.precision);
    }

    /**
     * Format coordinate as integer for drill files
     */
    formatCoordinateInt(value) {
        const multiplier = this.settings.units === 'mm' ? 1000 : 25400; // Convert to micrometers or microinches
        return Math.round(value * multiplier).toString();
    }

    /**
     * Download Gerber files as ZIP
     */
    async downloadGerberZip() {
        const files = await this.exportGerberSet();
        
        // Create ZIP file (simplified implementation)
        // In a real implementation, you'd use a ZIP library like JSZip
        const zipContent = this.createSimpleZip(files);
        
        const blob = new Blob([zipContent], { type: 'application/zip' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = 'gerbers.zip';
        a.click();
        
        URL.revokeObjectURL(url);
    }

    /**
     * Create simple ZIP-like archive (placeholder)
     * In production, use a proper ZIP library
     */
    createSimpleZip(files) {
        let archive = '';
        Object.entries(files).forEach(([filename, content]) => {
            archive += `--- ${filename} ---\n${content}\n\n`;
        });
        return archive;
    }
}

// Export for use in other modules
window.GerberExporter = GerberExporter;
